.TH fermi 1 "30 November 2011" "fermi-r426" "Bioinformatics tools"

.SH NAME
.PP
fermi - FERragina-Manzini Index for DNA sequences

.SH SYNOPSIS
.PP
fermi build seq1.fq > seq1.fmd
.PP
fermi build seq2.fq > seq2.fmd
.PP
fermi merge -t 4 seq1.fmd seq2.fmd > seq12.fmd
.PP
cat seq1.fq seq2.fq | fermi correct seq12.fmd - > seq12.ec.fa
.PP
fermi build seq12.ec.fa > seq12.ec.fmd
.PP
fermi unitig seq12.ec.fmd > seq12.ec.msg
.PP
fermi clean -C seq12.ec.msg > seq12.contigs

.SH DESCRIPTION
.PP
Fermi is a set of tools blablabla...

.SH COMMANDS AND OPTIONS
.sp
\ 
.SS Assembly related commands

.TP 10
.B build
.B fermi build
.RB [ \-f ]
.RB [ \-i
.IR in.fmd ]
.RB [ \-b
.IR sbits ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-s
.IR blkSize ]
.I in.fa

Construct the FM-index for file
.I in.fa
or append the constructed index to an existing FM-index
.IR in.fmd .
For a small input file, all the sequences will be loaded into memory and the
index is constructed altogether. For a large file, this command will load
.I blkSize
symbols in turn, construct BWT for them and then append to the existing index
using an algorithm similar to the
.B merge
command. For a large file, the memory consumption is about
.RI ( S + blkSize *13),
where
.I S
is the size of the final FM-index.


.TP
.B merge
.B fermi merge
.RB [ \-f ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-t
.IR nThreads ]
.I in0.fmd in1.fmd
.RI [ ... ]

Merge multiple FM-indexes. This step takes about
.RI ( N /8+ S )
bytes of memory, where
.I N
is the total length of the concatenated sequence and
.I S
is the size of the final FM-index which is run-length-delta encoded.


.TP
.B correct
.B fermi correct
.RB [ \-K ]
.RB [ \-k
.IR kMerSize ]
.RB [ \-O
.IR minOcc ]
.RB [ \-t
.IR nThreads ]
.RB [ \-C
.IR maxCorr ]
.I in.fmd in.fa

Collect the k-mer count from
.I in.fmd
and use the collected informtion to fix sequencing errors in
.IR in.fa .


.TP
.B seqrank
.B fermi seqrank
.RB [ \-t
.IR nThreads ]
.RI > out.rank

Compute the rank of each sequence and output a binary file to be used with
.BR unitig .


.TP
.B unitig
.B fermi unitig
.RB [ \-l
.IR minOvlp ]
.RB [ \-t
.IR nThreads ]
.RB [ \-r
.IR rankFile ]
.RB [ \-s
.IR seqFile ]
.I in.fmd

Construct the unitig graph from
.I in.fmd
by unambiguously and maximally extending each read. This command has three modes.
Firstly, when neither
.B -r
nor
.B -s
is specified, the
.B unitig
command assumes the input is single-end data. It unambiguously extends a sequence
until it meets a bifurcation. The resulting sequences are unitigs. The connections
between unitigs are also kept.
Secondly, when
.B -r
is in use, the command regards the input is paired-end data. It then tries to use
the paired-end information to avoid some bifurcations. However, the output is not
strictly unitigs and the command is unable to keep all the connections between
output sequences. This makes it necessary to have a third mode: when 
.B -s
is specified, the
.B unitig
command only generates the overlap information between input sequences without extension.
This mode aims to fix the missing connections in the paired-end mode.

.B OPTIONS:
.RS
.TP 10
.BI \-l \ INT
Length of the minimum overlap [30]
.TP
.BI \-t \ INT
Number of threads [1]
.TP
.BI \-r \ FILE
The output file generated by
.BR seqrank .
The
.I FILE
here must be generated from
.IR in.fmd .
When this option is in use, the (2*i) and (2*i+1)-th sequences form a pair. [null]
.TP
.BI \-s \ FILE
The exact sequence file that is used to generate the index
.IR in.fmd .
The sequence file must contain the same number of sequences and
in the same order as in the index file
.IR in.fmd .
When this option is in use, this command only generates overlaps between sequences
but does not extend. The purpose of this option is to construct the overlap graph
while retaining the quality/depth information in the input. [null]
.RE


.TP
.B clean
.B fermi clean
.RB [ \-CA ]
.RB [ \-N
.IR maxNei ]
.RB [ \-d
.IR minRatio1 ]
.RB [ \-l
.IR minTipLen ]
.RB [ \-o
.IR minOvlp ]
.RB [ \-R
.IR minRatio2 ]
.RB [ \-n
.IR nIters ]
.RB [ \-w
.IR minBblCov ]
.RB [ \-r
.IR minBblRatio ]
.I in.msg

Clean unitig graph
.IR in.msg .

.SS Sequence processing commands

.TP 10
.B pe2cofq
.B fermi pe2cofq
.I in1.fastq in2.fastq
.B >
.I collated.fastq

Collate
.I in1.fastq
and
.I in2.fastq
produced from a paired-end run where the
.IR i -th
sequence in
.I in1.fastq
and the
.IR i -th
sequence in
.I in2.fastq
constitute a read pair.


.TP
.B trimseq
.B fermi trimseq
.RB [ \-N ]
.RB [ \-q
.IR minQual ]
.RB [ \-l
.IR minLen ]
.I in.fastq

Trim both low-quality ends of a read and possibly drop reads with low quality.
For collated paired-end FASTQ files, if a read is dropped, its mate (judged from the read name) will also be dropped.

.B OPTIONS:
.RS
.TP 10
.B \-N
Keep reads containing ambiguous bases after trimming. Such reads are dropped by default.
.TP
.BI \-q \ INT
Minimum base quality. For 3'-end trimming, reads are trimmed down to
.RI argmax_x{sum_{i=x}^l( INT -q_i)}
where q_i is the base quality of the
.IR i -th
base. 5'-end trimming is similar. [3]
.TP
.BI \-l \ INT
Discard a read if after trimming the read length is below
.I INT
[20]
.RE

.SS Other commands

.TP 10
.B unpack
.B fermi unpack
.RB [ \-M ]
.RB [ \-i
.IR index ]
.I in.fmd

Extract multiple or all sequences stored in the FM-index.


.TP
.B chkbwt
.B fermi chkbwt
.RB [ \-MP ]
.I in.fmd

Check the rank function or print the BWT in the text form.


.TP
.B exact
.B fermi exact
.RB [ \-sM ]
.I in.fmd in.fa

Find the super-maximal exact matches against the FM-index.


.SH NOTES
.sp
\ 

.SS The goal of Fermi
.PP
Fermi aims to bring the power of de novo assembly to resequencing. (to be continued)

.SS Fermi and SGA
.PP
Fermi is fundamentally influenced by the string graph assembler (SGA) written
by Jared Simpson. Although initially I was planning something quite different,
most of my ideas turned out to be wrong or impractical once I started to
implement them. At the end of day, fermi takes a very similar overall approach
to SGA. On the other hand, fermi after all is a fresh implementation. The
FM-index data structure, the BWT construction algorithm, the error correction
strategy, the overlap graph construction procedure are all different from those
implemented in SGA.


.SH AUTHOR
.PP
Heng Li <lh3@me.com> implemented
.BR fermi .

.SH SEE ALSO
.PP
Fermi web site.
