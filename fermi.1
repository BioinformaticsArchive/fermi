.TH fermi 1 "14 December 2011" "fermi-r457" "Bioinformatics tools"

.SH NAME
.PP
fermi - FERragina-Manzini Index for DNA sequences

.SH SYNOPSIS
.PP
run-fermi.pl -p pe -Pt 8 end1.fq end2.fq > assemble.mak
.PP
make -f assemble.mak -j 8
.PP
fermi clean -C pe.msg.gz > pe.contigs.fq

.SH DESCRIPTION
.PP
(to be added...)

.SH COMMANDS AND OPTIONS
.sp
\ 
.SS Quick assembly with run-fermi.pl

.B run-fermi.pl
.RB [ \-Pc ]
.RB [ \-e
.IR fermiExe ]
.RB [ \-t
.IR nCPUs ]
.RB [ \-p
.IR prefix ]
.RB [ \-f
.IR uniqFltK ]
.RB [ \-k
.IR ovlpLen ]
.I in1.fq.gz
.RI [ in2.fq.gz ]
.BI > assemble.mak

Generate a Makefile to assembly input reads. To actually perform the assembly,
one should use
.RB ` make
-f
.I assemble.mak
-j
.IR nCPUs ',
where
.I nCPUs
is the option used for generating the Makefile. The end assembly output is
.IR prefix .msg.gz
which is an overlap graph in a FASTQ-like format: a quality line in FASTQ
gives the per-base read depth. One should further use the
.B clean
command or another assembler to remove tips and bubbles. 

In addition to the final assembly graph, the following files are also generated
as useful intermediate results:
.IR prefix .raw.fmd,
the FM-index of the raw sequence reads;
.IR prefix .ec.fq.gz,
the error-corrected read sequences;
.IR prefix .ec.fmd,
the FM-index of the error-corrected reads.

.B OPTIONS:
.TP 10
.B -c
The input is collated paired-end FASTQs where the
.RI 2* i -th
and
.RI 2*( i +1)-th
reads in each input file constitute a read pair.
.TP
.B -P
The input is separated paired-end FASTQ pairs where the
.IR i -th
read in the
.RI 2* j -th
input file and the
.IR i -th
read in the
.RI 2*( j +1)-th
file constitute a read pair.
.TP
.BI -e \ FILE
Path of the
.B fermi
executable [fermi]
.TP
.BI -p \ STR
Prefix of output files [fmdef]
.TP
.BI -t \ INT
Maximum number of CPUs. Must be a number no less than 2. [2]
.TP
.BI -f \ INT
K-mer length used for filtering unique mers (see also
.BR fltuniq ).
Typically between 16 and 18. [17]
.TP
.BI -k \ INT
Minimum overlap when constructing unitigs (see also
.BR unitig ).
[50]


.SS Assembly related commands

.TP 10
.B build
.B fermi build
.RB [ \-f ]
.RB [ \-i
.IR in.fmd ]
.RB [ \-b
.IR sbits ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-s
.IR blkSize ]
.I in.fa

Construct the FM-index for file
.I in.fa
or append the constructed index to an existing FM-index
.IR in.fmd .
For a small input file, all the sequences will be loaded into memory and the
index is constructed altogether. For a large file, this command will load
.I blkSize
symbols in turn, construct BWT for them and then append to the existing index
using an algorithm similar to the
.B merge
command. For a large file, the memory consumption is about
.RI ( S + blkSize *13),
where
.I S
is the size of the final FM-index.


.TP
.B merge
.B fermi merge
.RB [ \-f ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-t
.IR nThreads ]
.I in0.fmd in1.fmd
.RI [ ... ]

Merge multiple FM-indexes. This step takes about
.RI ( N /8+ S )
bytes of memory, where
.I N
is the total length of the concatenated sequence and
.I S
is the size of the final FM-index which is run-length-delta encoded.


.TP
.B correct
.B fermi correct
.RB [ \-K ]
.RB [ \-k
.IR kMerSize ]
.RB [ \-O
.IR minOcc ]
.RB [ \-t
.IR nThreads ]
.RB [ \-C
.IR maxCorr ]
.I in.fmd in.fa

Collect the k-mer count from
.I in.fmd
and use the collected informtion to fix sequencing errors in
.IR in.fa .


.TP
.B seqrank
.B fermi seqrank
.RB [ \-t
.IR nThreads ]
.RI > out.rank

Compute the rank of each sequence and output a binary file to be used with
.BR unitig .


.TP
.B unitig
.B fermi unitig
.RB [ \-l
.IR minOvlp ]
.RB [ \-t
.IR nThreads ]
.RB [ \-r
.IR rankFile ]
.RB [ \-s
.IR seqFile ]
.I in.fmd

Construct the unitig graph from
.I in.fmd
by unambiguously and maximally extending each read. This command has three modes.
Firstly, when neither
.B -r
nor
.B -s
is specified, the
.B unitig
command assumes the input is single-end data. It unambiguously extends a sequence
until it meets a bifurcation. The resulting sequences are unitigs. The connections
between unitigs are also kept.
Secondly, when
.B -r
is in use, the command regards the input is paired-end data. It then tries to use
the paired-end information to avoid some bifurcations. However, the output is not
strictly unitigs and the command is unable to keep all the connections between
output sequences. This makes it necessary to have a third mode: when 
.B -s
is specified, the
.B unitig
command only generates the overlap information between input sequences without extension.
This mode aims to fix the missing connections in the paired-end mode.

.B OPTIONS:
.RS
.TP 10
.BI \-l \ INT
Length of the minimum overlap [30]
.TP
.BI \-t \ INT
Number of threads [1]
.TP
.BI \-r \ FILE
The output file generated by
.BR seqrank .
The
.I FILE
here must be generated from
.IR in.fmd .
When this option is in use, the (2*i) and (2*i+1)-th sequences form a pair. [null]
.TP
.BI \-s \ FILE
The exact sequence file that is used to generate the index
.IR in.fmd .
The sequence file must contain the same number of sequences and
in the same order as in the index file
.IR in.fmd .
When this option is in use, this command only generates overlaps between sequences
but does not extend. The purpose of this option is to construct the overlap graph
while retaining the quality/depth information in the input. [null]
.RE


.TP
.B clean
.B fermi clean
.RB [ \-CA ]
.RB [ \-N
.IR maxNei ]
.RB [ \-d
.IR minRatio1 ]
.RB [ \-l
.IR minTipLen ]
.RB [ \-o
.IR minOvlp ]
.RB [ \-R
.IR minRatio2 ]
.RB [ \-n
.IR nIters ]
.RB [ \-w
.IR minBblCov ]
.RB [ \-r
.IR minBblRatio ]
.I in.msg

Clean unitig graph
.IR in.msg .

.SS Sequence processing commands

.TP 10
.B pe2cofq
.B fermi pe2cofq
.I in1.fastq in2.fastq
.B >
.I collated.fastq

Collate
.I in1.fastq
and
.I in2.fastq
produced from a paired-end run where the
.IR i -th
sequence in
.I in1.fastq
and the
.IR i -th
sequence in
.I in2.fastq
constitute a read pair.


.TP
.B trimseq
.B fermi trimseq
.RB [ \-N ]
.RB [ \-q
.IR minQual ]
.RB [ \-l
.IR minLen ]
.I in.fastq

Trim both low-quality ends of a read and possibly drop reads with low quality.
For collated paired-end FASTQ files, if a read is dropped, its mate (judged from the read name) will also be dropped.

.B OPTIONS:
.RS
.TP 10
.B \-N
Keep reads containing ambiguous bases after trimming. Such reads are dropped by default.
.TP
.BI \-q \ INT
Minimum base quality. For 3'-end trimming, reads are trimmed down to
.RI argmax_x{sum_{i=x}^l( INT -q_i)}
where q_i is the base quality of the
.IR i -th
base. 5'-end trimming is similar. [3]
.TP
.BI \-l \ INT
Discard a read if after trimming the read length is below
.I INT
[20]
.RE

.SS Other commands

.TP 10
.B unpack
.B fermi unpack
.RB [ \-M ]
.RB [ \-i
.IR index ]
.I in.fmd

Extract multiple or all sequences stored in the FM-index.


.TP
.B chkbwt
.B fermi chkbwt
.RB [ \-MP ]
.I in.fmd

Check the rank function or print the BWT in the text form.


.TP
.B exact
.B fermi exact
.RB [ \-sM ]
.I in.fmd in.fa

Find the super-maximal exact matches against the FM-index.


.SH NOTES
.sp
\ 
.SS Fermi and SGA
.PP
Fermi is fundamentally influenced by the string graph assembler (SGA) written
by Jared Simpson. Although initially I was planning something quite different,
most of my ideas turned out to be wrong or impractical once I started to
implement them. At the end of day, fermi takes a very similar overall approach
to SGA. On the other hand, fermi after all is a fresh implementation. The
FM-index data structure, the BWT construction algorithm, the error correction
strategy, the overlap graph construction procedure are all different from those
implemented in SGA.

.SS Current development status
.PP
Fermi works fairly well for single-end HiSeq data. The corrected contiguity is
comparable to or at times better than other assemblers. The number of
misassemblies is unfortunately is a little higher in comparison to SGA and
SOAPdenovo. For paired-end data, fermi relies on other assemblers for
scaffolding. Thus by itself fermi is unable to produce scafftigs - ungapped
fragments contained in scaffolds - which are frequently longer than the raw
unitigs. To compensate the lack of functionality, fermi can construct unitigs
with the pairing information and thus produces longer unitigs in the paired-end
mode. Fermi is unable to make use of jumping libraries at the moment.


.SH AUTHOR
.PP
Heng Li <lh3@me.com> implemented
.BR fermi .

.SH SEE ALSO
.PP
Fermi git repository: <https://github.com/lh3/fermi>
