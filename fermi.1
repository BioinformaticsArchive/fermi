.TH fermi 1 "5 January 2012" "fermi-r513" "Bioinformatics tools"

.SH NAME
.PP
fermi - FERragina-Manzini Index for DNA sequences

.SH SYNOPSIS
.PP
run-fermi.pl -p prefix -Pt 8 end1.fq end2.fq > assemble.mak
.PP
make -f assemble.mak -j 8
.PP
fermi clean -C prefix.msg.gz > prefix.contigs.fq

.SH DESCRIPTION
.PP
Fermi is a light-weight de novo assembler for Illumina sequence reads. It is
one of the few assemblers that is capable of assembling a mammalian genome.
Fermi is a good assembler for unitig construction, but its ultimate goal
is not to become the best assembler but to provide an alternative approach to
resequencing and to data compression. It relies on the `coherence' property of
unitigs (Myers 2005) to represent (ideally) all information in reads such that
further analyses can be carried on the unitigs rather than raw reads.

.SS Hardware requirement
Fermi is designed for running on a multi-core machine with large shared memory.
The peak memory is linear in the size of the genome and sublinear in the coverage.
It requires a minimum 90GB memory to assemble a mammalian genome at 35-fold
coverage. Probably fermi runs on x86_64 CPUs only due to the large memory
requirements and assumptions on the byte order, though the latter can be
relaxed in theory.

.SS Running fermi
The easiest way to run fermi is to use the
.B run-fermi.pl
script. This script takes multiple single-end or paired-end FASTQ files as input
and outputs a Makefile which can be used with the
.B make
command to do the actual assembly. The end output after this procedure is a raw
overlap graph with per-base coverage of non-contained reads. An additional
graph cleaning step is needed, but future versions of fermi may incorporate
this step in the Makefile as well. The following are a few examples:

.IP o 2
Assemble a bacterial genome:

  run-fermi.pl -Pe ./fermi read1.fq.gz read2.fq.gz > Makefile
  make
  ./fermi clean -C fmdef.msg.gz > fmdef.contigs
 
.IP o 2
Assemble a C. elegans genome:

  run-fermi.pl -t8 -Pk50 -p ce SRR065390_1.fq SRR065390_2.fq > ce.mak
  make -j8 -f ce.mak
  fermi clean -Co70 -l250 ce.msg.gz > ce.contigs

.IP o 2
Assemble a human genome:

  run-fermi.pl -t16 -Pk50 -f18 s_1_1.fq s_1_2.fq s_2_1.fq s_2_2.fq > human.mak
  make -j16 -f human.mak
  fermi clean -C -r0.15 -o70 fmdef.msg.gz > human-reseq.ctg
  fermi clean -CA fmdef.ext.msg.gz > human-long-N50.ctg

.SH COMMANDS AND OPTIONS
.sp
\ 
.SS Quick assembly with run-fermi.pl
.B run-fermi.pl
.RB [ \-PAc ]
.RB [ \-e
.IR fermiExe ]
.RB [ \-t
.IR nCPUs ]
.RB [ \-p
.IR prefix ]
.RB [ \-f
.IR uniqFltK ]
.RB [ \-k
.IR ovlpLen ]
.I in1.fq.gz
.RI [ in2.fq.gz ]
.BI > assemble.mak

Generate a Makefile to assembly input reads. To actually perform the assembly,
one should use
.RB ` make
-f
.I assemble.mak
-j
.IR nCPUs ',
where
.I nCPUs
is the option used for generating the Makefile. The end assembly output for single-end data is
.IR prefix .msg.gz
which is an overlap graph in a FASTQ-like format with the original quality line
encoding the per-base read depth. One should further use the
.B clean
command or another assembler to remove tips and bubbles. For paired-end data, file 
.IR prefix .ext.msg.gz
is the final output which considers the pairing information during contig construction.

In addition to the final assembly graph, the following files are also generated
as potentially useful intermediate results:
.IR prefix .raw.fmd,
the FM-index of the raw sequence reads;
.IR prefix .ec.fq.gz,
the error-corrected read sequences;
.IR prefix .ec.fmd,
the FM-index of the error-corrected reads.

.B OPTIONS:
.TP 10
.B -c
The input is collated paired-end FASTQs where the
.RI 2* i -th
and
.RI 2*( i +1)-th
reads in each input file constitute a read pair.
.TP
.B -P
The input is separated paired-end FASTQ pairs where the
.IR i -th
read in the
.RI 2* j -th
input file and the
.IR i -th
read in the
.RI 2*( j +1)-th
file constitute a read pair.
.TP
.BI -e \ FILE
Path of the
.B fermi
executable [fermi]
.TP
.BI -p \ STR
Prefix of output files [fmdef]
.TP
.BI -t \ INT
Maximum number of CPUs. Must be a number no less than 2. [2]
.TP
.BI -f \ INT
K-mer length used for filtering unique mers (see also
.BR fltuniq ).
Typically between 16 and 18. [17]
.TP
.BI -k \ INT
Minimum overlap when constructing unitigs (see also
.BR unitig ).
[50]


.SS Assembly related commands

.TP 10
.B build
.B fermi build
.RB [ \-f ]
.RB [ \-i
.IR in.fmd ]
.RB [ \-b
.IR sbits ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-s
.IR blkSize ]
.I in.fa

Construct the FM-index for file
.I in.fa
or append the constructed index to an existing FM-index
.IR in.fmd .
For a small input file, all the sequences will be loaded into memory and the
index is constructed altogether. For a large file, this command will load
.I blkSize
symbols in turn, construct BWT for them and then append to the existing index
using an algorithm similar to the
.B merge
command. For a large file, the memory consumption is about
.RI ( S + blkSize *13),
where
.I S
is the size of the final FM-index.


.TP
.B merge
.B fermi merge
.RB [ \-f ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-t
.IR nThreads ]
.I in0.fmd in1.fmd
.RI [ ... ]

Merge multiple FM-indexes. This step takes about
.RI ( N /8+ S )
bytes of memory, where
.I N
is the total length of the concatenated sequence and
.I S
is the size of the final FM-index which is run-length-delta encoded.


.TP
.B correct
.B fermi correct
.RB [ \-K ]
.RB [ \-k
.IR kMerSize ]
.RB [ \-O
.IR minOcc ]
.RB [ \-t
.IR nThreads ]
.RB [ \-C
.IR maxCorr ]
.I in.fmd in.fa

Collect the k-mer count from
.I in.fmd
and use the collected informtion to fix sequencing errors in
.IR in.fa .


.TP
.B seqrank
.B fermi seqrank
.RB [ \-t
.IR nThreads ]
.RI > out.rank

Compute the rank of each sequence and output a binary file to be used with
.BR unitig .


.TP
.B unitig
.B fermi unitig
.RB [ \-l
.IR minOvlp ]
.RB [ \-t
.IR nThreads ]
.RB [ \-r
.IR rankFile ]
.I in.fmd

Construct the unitig graph from
.I in.fmd
by unambiguously and maximally extending each read. When
.B -r
is specified, this command assumes the input are paired. It then estimates
the mean and the standard deviation of the insert size distribution and
records the read positions of unpaired reads.

.B OPTIONS:
.RS
.TP 10
.BI \-l \ INT
Length of the minimum overlap [30]
.TP
.BI \-t \ INT
Number of threads [1]
.TP
.BI \-r \ FILE
The output file generated by
.BR seqrank .
The
.I FILE
here must be generated from
.IR in.fmd .
When this option is in use, the (2*i) and (2*i+1)-th sequences form a pair. [null]
.RE


.TP
.B clean
.B fermi clean
.RB [ \-CA ]
.RB [ \-N
.IR maxNei ]
.RB [ \-d
.IR minRatio1 ]
.RB [ \-l
.IR minTipLen ]
.RB [ \-o
.IR minOvlp ]
.RB [ \-R
.IR minRatio2 ]
.RB [ \-n
.IR nIters ]
.RB [ \-w
.IR minBblCov ]
.RB [ \-r
.IR minBblRatio ]
.I in.msg

Clean unitig graph
.IR in.msg .

.SS Sequence processing commands

.TP 10
.B pe2cofq
.B fermi pe2cofq
.I in1.fastq in2.fastq
.B >
.I collated.fastq

Collate
.I in1.fastq
and
.I in2.fastq
produced from a paired-end run where the
.IR i -th
sequence in
.I in1.fastq
and the
.IR i -th
sequence in
.I in2.fastq
constitute a read pair.


.TP
.B trimseq
.B fermi trimseq
.RB [ \-N ]
.RB [ \-q
.IR minQual ]
.RB [ \-l
.IR minLen ]
.I in.fastq

Trim both low-quality ends of a read and possibly drop reads with low quality.
For collated paired-end FASTQ files, if a read is dropped, its mate (judged from the read name) will also be dropped.

.B OPTIONS:
.RS
.TP 10
.B \-N
Keep reads containing ambiguous bases after trimming. Such reads are dropped by default.
.TP
.BI \-q \ INT
Minimum base quality. For 3'-end trimming, reads are trimmed down to
.RI argmax_x{sum_{i=x}^l( INT -q_i)}
where q_i is the base quality of the
.IR i -th
base. 5'-end trimming is similar. [3]
.TP
.BI \-l \ INT
Discard a read if after trimming the read length is below
.I INT
[20]
.RE

.SS Other commands

.TP 10
.B unpack
.B fermi unpack
.RB [ \-M ]
.RB [ \-i
.IR index ]
.I in.fmd

Extract multiple or all sequences stored in the FM-index.


.TP
.B chkbwt
.B fermi chkbwt
.RB [ \-MP ]
.I in.fmd

Check the rank function or print the BWT in the text form.


.TP
.B exact
.B fermi exact
.RB [ \-sM ]
.I in.fmd in.fa

Find the super-maximal exact matches against the FM-index.


.SH FURTHER NOTES
.sp
\ 

.SS Fermi and SGA
.PP
Fermi is fundamentally influenced by the string graph assembler (SGA; Simpson and Durbin, 2010 and 2012) written
by Jared Simpson. Although initially I was planning something quite different,
most of my ideas turned out to be wrong or impractical once I started to
implement them. In the end, fermi takes a very similar overall approach to SGA.
On the other hand, fermi is entirely a fresh implementation. The FM-index data
structure, the BWT construction algorithm, the error correction strategy, the
overlap graph construction procedure are all different from those
implemented in SGA.

.SS Limitations
.PP
As of now, fermi is designed and extensively tested for 100bp Illumina
paired-end data from a single short-insert library or libraries of similar
insert sizes. It is able to use the pairing information for the unitig
construction, but it does not generate scaffolds and is unable to take
advantage of reads from jumping libraries. Thus users may need a third-party
scaffolder to construct scaffolds and/or to take advantage of reads with
long-insert. In addition, fermi does not work with long reads having a high
indel sequencing error rate, though it has the potential to be applied to such
data in future.

.SS Performance
.PP
Fermi works well for single-end HiSeq data. The corrected unitig N50 is
usually longer than other assemblers, though as a tradeoff the misassembly rate
may be a little higher in comparison to SGA and SOAPdenovo. For paired-end data,
fermi extends unitigs by doing local assembly around the ends. This usually
yields contigs of length comparable to the scaftigs produced by other assemblers.

During error correction, fermi rarely removes heterozygotes. For the NA12878
35X data set, the error correction only significantly affects 0.2% of SNPs. As
of now, unitigs may miss a significant fraction of heterozygous SNPs. Future
versions are likely to be improved at this point.

Like SGA, fermi effectively trades speed for a small memory footprint. It also
strives for minimal disk usage, which further slows fermi down. Given 35X human
data, fermi takes roughly 7 days using 16 CPUs with the memory peaking around 85GB.

.SS Unitig, contig, scaftig and scaffold
.PP
Given a haploid genome and sequence reads from the genome, a
.I unitig
is a subsequence of the genome that cannot be extended unambiguously with the
sequence reads and is not contained in other unitigs. A unitig may have
multiple copies in the genome, but these copies are indistinguishable from the
sequence reads. Given paired-end data, a
.I scaffold
is a sequence consisting of unitigs and possibly gaps between them that are
inferred from the pairing information. A contiguous subsequence
in a scaffold is a
.IR scaftig .
As read pairs may resolve small repeats and reveal undetected overlaps, scaftigs
are usually longer than unitigs. A
.IR contig ,
by definition, is a contiguous sequence. It is a more generic concept.
We may regard unitigs, scaftigs or a walk along unitigs as contigs.


.SH AUTHOR
.PP
Heng Li <lh3@me.com>

.SH SEE ALSO
.PP
Fermi git repository: <https://github.com/lh3/fermi>
