.TH fermi 1 "14 December 2011" "fermi-r457" "Bioinformatics tools"

.SH NAME
.PP
fermi - FERragina-Manzini Index for DNA sequences

.SH SYNOPSIS
.PP
run-fermi.pl -p prefix -Pt 8 end1.fq end2.fq > assemble.mak
.PP
make -f assemble.mak -j 8
.PP
fermi clean -C pe.msg.gz > pe.contigs.fq

.SH DESCRIPTION
.PP
(to be added...)

.SH COMMANDS AND OPTIONS
.sp
\ 
.SS Quick assembly with run-fermi.pl

.B run-fermi.pl
.RB [ \-PAc ]
.RB [ \-e
.IR fermiExe ]
.RB [ \-t
.IR nCPUs ]
.RB [ \-p
.IR prefix ]
.RB [ \-f
.IR uniqFltK ]
.RB [ \-k
.IR ovlpLen ]
.I in1.fq.gz
.RI [ in2.fq.gz ]
.BI > assemble.mak

Generate a Makefile to assembly input reads. To actually perform the assembly,
one should use
.RB ` make
-f
.I assemble.mak
-j
.IR nCPUs ',
where
.I nCPUs
is the option used for generating the Makefile. The end assembly output for single-end data is
.IR prefix .msg.gz
which is an overlap graph in a FASTQ-like format: a quality line in FASTQ
gives the per-base read depth. One should further use the
.B clean
command or another assembler to remove tips and bubbles. For paired-end data, file 
.IR prefix .ext.msg.gz
is the final output which considers the pairing information during contig construction.

In addition to the final assembly graph, the following files are also generated
as potentially useful intermediate results:
.IR prefix .raw.fmd,
the FM-index of the raw sequence reads;
.IR prefix .ec.fq.gz,
the error-corrected read sequences;
.IR prefix .ec.fmd,
the FM-index of the error-corrected reads.

.B OPTIONS:
.TP 10
.B -c
The input is collated paired-end FASTQs where the
.RI 2* i -th
and
.RI 2*( i +1)-th
reads in each input file constitute a read pair.
.TP
.B -P
The input is separated paired-end FASTQ pairs where the
.IR i -th
read in the
.RI 2* j -th
input file and the
.IR i -th
read in the
.RI 2*( j +1)-th
file constitute a read pair.
.TP
.BI -e \ FILE
Path of the
.B fermi
executable [fermi]
.TP
.BI -p \ STR
Prefix of output files [fmdef]
.TP
.BI -t \ INT
Maximum number of CPUs. Must be a number no less than 2. [2]
.TP
.BI -f \ INT
K-mer length used for filtering unique mers (see also
.BR fltuniq ).
Typically between 16 and 18. [17]
.TP
.BI -k \ INT
Minimum overlap when constructing unitigs (see also
.BR unitig ).
[50]


.SS Assembly related commands

.TP 10
.B build
.B fermi build
.RB [ \-f ]
.RB [ \-i
.IR in.fmd ]
.RB [ \-b
.IR sbits ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-s
.IR blkSize ]
.I in.fa

Construct the FM-index for file
.I in.fa
or append the constructed index to an existing FM-index
.IR in.fmd .
For a small input file, all the sequences will be loaded into memory and the
index is constructed altogether. For a large file, this command will load
.I blkSize
symbols in turn, construct BWT for them and then append to the existing index
using an algorithm similar to the
.B merge
command. For a large file, the memory consumption is about
.RI ( S + blkSize *13),
where
.I S
is the size of the final FM-index.


.TP
.B merge
.B fermi merge
.RB [ \-f ]
.RB [ \-o
.IR out.fmd ]
.RB [ \-t
.IR nThreads ]
.I in0.fmd in1.fmd
.RI [ ... ]

Merge multiple FM-indexes. This step takes about
.RI ( N /8+ S )
bytes of memory, where
.I N
is the total length of the concatenated sequence and
.I S
is the size of the final FM-index which is run-length-delta encoded.


.TP
.B correct
.B fermi correct
.RB [ \-K ]
.RB [ \-k
.IR kMerSize ]
.RB [ \-O
.IR minOcc ]
.RB [ \-t
.IR nThreads ]
.RB [ \-C
.IR maxCorr ]
.I in.fmd in.fa

Collect the k-mer count from
.I in.fmd
and use the collected informtion to fix sequencing errors in
.IR in.fa .


.TP
.B seqrank
.B fermi seqrank
.RB [ \-t
.IR nThreads ]
.RI > out.rank

Compute the rank of each sequence and output a binary file to be used with
.BR unitig .


.TP
.B unitig
.B fermi unitig
.RB [ \-l
.IR minOvlp ]
.RB [ \-t
.IR nThreads ]
.RB [ \-r
.IR rankFile ]
.I in.fmd

Construct the unitig graph from
.I in.fmd
by unambiguously and maximally extending each read. When
.B -r
is specified, this command assumes the input are paired. It then estimates
the mean and the standard deviation of the insert size distribution and
records the read positions of unpaired reads.

.B OPTIONS:
.RS
.TP 10
.BI \-l \ INT
Length of the minimum overlap [30]
.TP
.BI \-t \ INT
Number of threads [1]
.TP
.BI \-r \ FILE
The output file generated by
.BR seqrank .
The
.I FILE
here must be generated from
.IR in.fmd .
When this option is in use, the (2*i) and (2*i+1)-th sequences form a pair. [null]
.RE


.TP
.B clean
.B fermi clean
.RB [ \-CA ]
.RB [ \-N
.IR maxNei ]
.RB [ \-d
.IR minRatio1 ]
.RB [ \-l
.IR minTipLen ]
.RB [ \-o
.IR minOvlp ]
.RB [ \-R
.IR minRatio2 ]
.RB [ \-n
.IR nIters ]
.RB [ \-w
.IR minBblCov ]
.RB [ \-r
.IR minBblRatio ]
.I in.msg

Clean unitig graph
.IR in.msg .

.SS Sequence processing commands

.TP 10
.B pe2cofq
.B fermi pe2cofq
.I in1.fastq in2.fastq
.B >
.I collated.fastq

Collate
.I in1.fastq
and
.I in2.fastq
produced from a paired-end run where the
.IR i -th
sequence in
.I in1.fastq
and the
.IR i -th
sequence in
.I in2.fastq
constitute a read pair.


.TP
.B trimseq
.B fermi trimseq
.RB [ \-N ]
.RB [ \-q
.IR minQual ]
.RB [ \-l
.IR minLen ]
.I in.fastq

Trim both low-quality ends of a read and possibly drop reads with low quality.
For collated paired-end FASTQ files, if a read is dropped, its mate (judged from the read name) will also be dropped.

.B OPTIONS:
.RS
.TP 10
.B \-N
Keep reads containing ambiguous bases after trimming. Such reads are dropped by default.
.TP
.BI \-q \ INT
Minimum base quality. For 3'-end trimming, reads are trimmed down to
.RI argmax_x{sum_{i=x}^l( INT -q_i)}
where q_i is the base quality of the
.IR i -th
base. 5'-end trimming is similar. [3]
.TP
.BI \-l \ INT
Discard a read if after trimming the read length is below
.I INT
[20]
.RE

.SS Other commands

.TP 10
.B unpack
.B fermi unpack
.RB [ \-M ]
.RB [ \-i
.IR index ]
.I in.fmd

Extract multiple or all sequences stored in the FM-index.


.TP
.B chkbwt
.B fermi chkbwt
.RB [ \-MP ]
.I in.fmd

Check the rank function or print the BWT in the text form.


.TP
.B exact
.B fermi exact
.RB [ \-sM ]
.I in.fmd in.fa

Find the super-maximal exact matches against the FM-index.


.SH NOTES
.sp
\ 

.SS Fermi and SGA
.PP
Fermi is fundamentally influenced by the string graph assembler (SGA) written
by Jared Simpson. Although initially I was planning something quite different,
most of my ideas turned out to be wrong or impractical once I started to
implement them. At the end of day, fermi takes a very similar overall approach
to SGA. On the other hand, fermi is entirely a fresh implementation. The
FM-index data structure, the BWT construction algorithm, the error correction
strategy, the overlap graph construction procedure are all different from those
implemented in SGA.

.SS Current development status
.PP
Fermi works well for single-end HiSeq data. The corrected unitig N50 is
comparable to or at times better than other assemblers, though the number of
misassemblies may be a little higher in comparison to SGA and SOAPdenovo.
For paired-end data, fermi locally assembles the ends of unitigs and takes
the local assembly as long reads to perform another round of unitig
construction for producing longer contigs that are of similar lengths to
scaftigs assembled by other assemblers.

.SS Unitig, contig, scaftig and scaffold
.PP
Given a haploid genome and sequence reads from the genome, a
.I unitig
is a subsequence of the genome that cannot be extended unambiguously with the
sequence reads and is not contained in other unitigs. A unitig may have
multiple copies in the genome, but these copies are indistinguishable from the
sequence reads. Given paired-end data, a
.I scaffold
is a sequence consisting of unitigs and possibly gaps between them that are
inferred from the pairing information. A contiguous subsequence
in a scaffold is a
.IR scaftig .
As read pairs may resolve small repeats and reveal undetected overlaps, scaftigs
are usually longer than unitigs. A
.IR contig ,
by definition, is a contiguous sequence. It is a more generic concept.
We may regard unitigs, scaftigs or a walk along unitigs as contigs.


.SH AUTHOR
.PP
Heng Li <lh3@me.com> implemented
.BR fermi .

.SH SEE ALSO
.PP
Fermi git repository: <https://github.com/lh3/fermi>
